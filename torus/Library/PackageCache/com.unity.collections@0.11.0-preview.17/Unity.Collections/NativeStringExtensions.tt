<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ template debug="True" #>
<#@ output extension=".gen.cs" #>
<#@ assembly name="System.Core" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/FixedStringExtensions.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Unity.Collections
{
    /// <summary>
    /// <undoc />
    /// </summary>
    public static class NativeStringExtensions
    {
        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="dest"></param>
        /// <param name="src"></param>
        /// <returns></returns>
        public static int Append<T>(this ref T dest, byte src)
            where T : unmanaged, INativeList<byte>
        {
            if (dest.Length == dest.Capacity)
                return -1;
            dest[dest.Length++] = src;
            return 0;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="U"></typeparam>
        /// <param name="dest"></param>
        /// <param name="src"></param>
        /// <returns></returns>
        public static int Append<T, U>(this ref T dest, in U src)
            where T : unmanaged, INativeList<byte>
            where U : unmanaged, INativeList<byte>
        {
            for (var i = 0; i < src.Length; ++i)
            {
                var error = dest.Append(src[i]);
                if (error != 0)
                    return error;
            }

            return 0;
        }

<#
    for(var ARGS = 1; ARGS <= 10; ++ARGS)
    {
        var TYPES  = "T0";
        var PARAMS = "in T0 arg0";
        var DOCS   =     "        /// <typeparam name=\"T0\"><undoc /></typeparam>"
                   + "\r\n        /// <param name=\"arg0\"><undoc /></param>"
                   ;

        for(var a = 1; a < ARGS; ++a)
        {
            TYPES  += ", T" + a;
            PARAMS += ", in T" + a + " arg" + a;
            DOCS   += "\r\n        /// <typeparam name=\"T" + a + "\"><undoc /></typeparam>"
                   +  "\r\n        /// <param name=\"arg" + a + "\"><undoc /></param>"
                   ;
        }
#>
        /// <summary>
        /// <undoc />
        /// </summary>
        /// <typeparam name="T"><undoc /></typeparam>
        /// <typeparam name="U"><undoc /></typeparam>
        /// <param name="dest"><undoc /></param>
        /// <param name="format"><undoc /></param>
<#=DOCS#>
        public static void Format<T, U, <#=TYPES#>>(this ref T dest, in U format, <#=PARAMS#>)
            where T : unmanaged, INativeList<byte>
            where U : unmanaged, INativeList<byte>
<#
        for(var a = 0; a < ARGS; ++a)
        {
            WriteLine("            where T{0} : unmanaged, INativeList<byte>", a);
        }
#>
        {
            for (var i = 0; i < format.Length; ++i)
            {
                if (format[i] == '{')
                {
                    if (format.Length - i >= 3 && format[i + 1] != '{')
                    {
                        var index = format[i + 1] - '0';
                        switch (index)
                        {
<#
        for(var a = 0; a < ARGS; ++a)
        {
            WriteLine("                            case {0}: dest.Append(arg{0}); i+=2; break;", a);
        }
#>
                            default:
                                dest.Append(format[i]);
                                break;
                        }
                    }
                }
                else
                    dest.Append(format[i]);
            }
        }

<#
    }
#>

    }
}
